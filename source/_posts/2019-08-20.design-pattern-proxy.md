---
title: 设计模式之结构型设计模式-代理模式
comments: true
fancybox: false
toc: false
date: 2019-08-20 18:24:49
tags:
- 设计模式
categories:
- 设计模式
- 结构型设计模式
description:
permalink: design-pattern-proxy
top:
---

## 1. 模式简介

为其他对象提供一种代理，以控制对这个对象的访问；代理对象就类似生活中的中介；属于`结构型设计模式`。

<!--more-->

## 2. 示例代码

### 2.1. 静态代理

> 显式声明被代理对象，仅可以代理某些对象

#### 2.1.1. 代码实现

- 具体实现

```java
/**
 * <p>
 * 售票接口
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:12
 */
public interface Ticket {
    /**
     * 卖票
     */
    void sell();
}

/**
 * <p>
 * 演唱会门票
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:16
 */
public class MusicTicket implements Ticket {
    /**
     * 卖票
     */
    @Override
    public void sell() {
        System.out.println("卖演唱会门票");
    }
}

/**
 * <p>
 * 静态代理类，演唱会售票员(只卖演唱会门票)
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:24
 */
public class MusicConductor implements Ticket {
    private MusicTicket ticket;

    /**
     * 只代理 演唱会门票
     * @param ticket 演唱会门票
     */
    public MusicConductor(MusicTicket ticket) {
        this.ticket = ticket;
    }

    /**
     * 卖票
     */
    @Override
    public void sell() {
        before();
        this.ticket.sell();
        after();
    }

    private void before() {
        System.out.println("静态代理 - 方法前增强");
    }

    private void after() {
        System.out.println("静态代理 - 方法后增强");
    }
}
```

- 测试类

```java
/**
 * <p>
 * 代理模式 - 静态代理，测试类
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:29
 */
public class PatternTest {
    public static void main(String[] args) {
        MusicConductor conductor = new MusicConductor(new MusicTicket());
        conductor.sell();
    }
}
```

- 测试结果

```bash
静态代理 - 方法前增强
卖演唱会门票
静态代理 - 方法后增强
```

#### 2.1.2. UML图例

<img src="https://static.xkcoding.com/blog/2019-08-21-proxy-staticproxy-uml.png" width="50%" alt="代理模式-静态代理"/>

### 2.2. 动态代理

> 动态配置和替换被代理对象，通俗的说就是可以代理任意一类对象，甚至是任意对象

#### 2.2.1. JDK动态代理

##### 2.2.1.1. 代码实现

- 具体实现

```java
/**
 * <p>
 * 售票接口
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:12
 */
public interface Ticket {
    /**
     * 卖票
     */
    void sell();
}

/**
 * <p>
 * 演唱会门票
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:16
 */
public class MusicTicket implements Ticket {
    /**
     * 卖票
     */
    @Override
    public void sell() {
        System.out.println("卖演唱会门票");
    }
}

/**
 * <p>
 * 体育比赛门票
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 23:07
 */
public class SportTicket implements Ticket {
    /**
     * 卖票
     */
    @Override
    public void sell() {
        System.out.println("体育比赛门票");
    }
}

/**
 * <p>
 * JDK动态代理类，售票员(不论什么票都卖)
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:35
 */
public class Conductor implements InvocationHandler {
    /**
     * 被代理对象
     */
    private Object target;

    /**
     * 可以代理任意门票，所以为 {@link Object}
     *
     * @param target 被代理对象，但是必须有统一的接口
     * @return 被代理对象
     */
    public Object getInstance(Object target) {
        this.target = target;
        Class<?> clazz = target.getClass();
        return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);
    }

    /**
     * 反射调用的方法
     *
     * @param proxy  代理对象
     * @param method 被代理对象需要执行的方法
     * @param args   被代理对象需要执行的方法 的参数
     * @return 被代理对象需要执行的方法 的返回值
     * @throws Throwable 抛出异常
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object result = method.invoke(target, args);
        after();
        return result;
    }

    private void before() {
        System.out.println("动态代理 - JDK动态代理 - 方法前增强");
    }

    private void after() {
        System.out.println("动态代理 - JDK动态代理 - 方法后增强");
    }
}
```

- 测试类

```java
/**
 * <p>
 * 代理模式 - 动态代理 - JDK动态代理，测试类
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 23:04
 */
public class PatternTest {
    public static void main(String[] args) {
        // 代理演唱会门票
        Ticket musicTicket = (Ticket) new Conductor().getInstance(new MusicTicket());
        musicTicket.sell();

        // 代理运动会门票
        Ticket sportTicket = (Ticket) new Conductor().getInstance(new SportTicket());
        sportTicket.sell();
    }
}
```

- 测试结果

```bash
动态代理 - JDK动态代理 - 方法前增强
卖演唱会门票
动态代理 - JDK动态代理 - 方法后增强
动态代理 - JDK动态代理 - 方法前增强
体育比赛门票
动态代理 - JDK动态代理 - 方法后增强
```

##### 2.2.1.2. UML图例

<img src="https://static.xkcoding.com/blog/2019-08-21-proxy-dynamicproxy-jdk-uml.png" alt="代理模式-动态代理-JDK动态代理" />

#### 2.2.2. CGLIB动态代理

##### 2.2.2.1. 代码实现

- 具体实现
- 测试类
- 测试结果

##### 2.2.2.2. UML图例

## 3. 应用



## 4. 场景



## 5. 优缺点



## 6. 拓展

### 6.1. JDK动态代理的原理分析



### 6.2. CGLIB动态代理的原理分析



### 6.3. Spring 中代理的选择原则



## 7. 完整代码地址

https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/structural/proxy