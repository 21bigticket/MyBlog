---
title: 设计模式之结构型设计模式-代理模式
comments: true
fancybox: false
toc: true
date: 2019-08-20 18:24:49
tags:
- 设计模式
categories:
- 设计模式
- 结构型设计模式
description:
permalink: design-pattern-proxy
top:
---

## 1. 模式简介

为其他对象提供一种代理，以控制对这个对象的访问；代理对象就类似生活中的中介；属于`结构型设计模式`。

<!--more-->

## 2. 示例代码

### 2.1. 静态代理

> 显式声明被代理对象，仅可以代理某些对象

#### 2.1.1. 代码实现

- 具体实现

```java
/**
 * <p>
 * 售票接口
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:12
 */
public interface Ticket {
    /**
     * 卖票
     */
    void sell();
}

/**
 * <p>
 * 演唱会门票
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:16
 */
public class MusicTicket implements Ticket {
    /**
     * 卖票
     */
    @Override
    public void sell() {
        System.out.println("卖演唱会门票");
    }
}

/**
 * <p>
 * 静态代理类，演唱会售票员(只卖演唱会门票)
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:24
 */
public class MusicConductor implements Ticket {
    private MusicTicket ticket;

    /**
     * 只代理 演唱会门票
     * @param ticket 演唱会门票
     */
    public MusicConductor(MusicTicket ticket) {
        this.ticket = ticket;
    }

    /**
     * 卖票
     */
    @Override
    public void sell() {
        before();
        this.ticket.sell();
        after();
    }

    private void before() {
        System.out.println("静态代理 - 方法前增强");
    }

    private void after() {
        System.out.println("静态代理 - 方法后增强");
    }
}
```

- 测试类

```java
/**
 * <p>
 * 代理模式 - 静态代理，测试类
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:29
 */
public class PatternTest {
    public static void main(String[] args) {
        MusicConductor conductor = new MusicConductor(new MusicTicket());
        conductor.sell();
    }
}
```

- 测试结果

```bash
静态代理 - 方法前增强
卖演唱会门票
静态代理 - 方法后增强
```

#### 2.1.2. UML 图例

<img src="https://static.xkcoding.com/blog/2019-08-21-proxy-staticproxy-uml.png" width="50%" alt="代理模式-静态代理"/>

### 2.2. 动态代理

> 动态配置和替换被代理对象，通俗的说就是可以代理任意一类对象，甚至是任意对象

#### 2.2.1. JDK 动态代理

> 注意：JDK代理时被代理类必须实现接口

##### 2.2.1.1. 代码实现

- 具体实现

```java
/**
 * <p>
 * 售票接口
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:12
 */
public interface Ticket {
    /**
     * 卖票
     */
    void sell();
}

/**
 * <p>
 * 演唱会门票
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:16
 */
public class MusicTicket implements Ticket {
    /**
     * 卖票
     */
    @Override
    public void sell() {
        System.out.println("卖演唱会门票");
    }
}

/**
 * <p>
 * 体育比赛门票
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 23:07
 */
public class SportTicket implements Ticket {
    /**
     * 卖票
     */
    @Override
    public void sell() {
        System.out.println("体育比赛门票");
    }
}

/**
 * <p>
 * JDK动态代理类，售票员(不论什么票都卖)
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:35
 */
public class Conductor implements InvocationHandler {
    /**
     * 被代理对象
     */
    private Object target;

    /**
     * 可以代理任意门票，所以为 {@link Object}
     *
     * @param target 被代理对象，但是必须有统一的接口
     * @return 被代理对象
     */
    public Object getInstance(Object target) {
        this.target = target;
        Class<?> clazz = target.getClass();
        return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);
    }

    /**
     * 反射调用的方法
     *
     * @param proxy  代理对象
     * @param method 被代理对象需要执行的方法
     * @param args   被代理对象需要执行的方法 的参数
     * @return 被代理对象需要执行的方法 的返回值
     * @throws Throwable 抛出异常
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object result = method.invoke(target, args);
        after();
        return result;
    }

    private void before() {
        System.out.println("动态代理 - JDK动态代理 - 方法前增强");
    }

    private void after() {
        System.out.println("动态代理 - JDK动态代理 - 方法后增强");
    }
}
```

- 测试类

```java
/**
 * <p>
 * 代理模式 - 动态代理 - JDK动态代理，测试类
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 23:04
 */
public class PatternTest {
    public static void main(String[] args) {
        // 代理演唱会门票
        Ticket musicTicket = (Ticket) new Conductor().getInstance(new MusicTicket());
        musicTicket.sell();

        // 代理运动会门票
        Ticket sportTicket = (Ticket) new Conductor().getInstance(new SportTicket());
        sportTicket.sell();
    }
}
```

- 测试结果

```bash
动态代理 - JDK动态代理 - 方法前增强
卖演唱会门票
动态代理 - JDK动态代理 - 方法后增强
动态代理 - JDK动态代理 - 方法前增强
体育比赛门票
动态代理 - JDK动态代理 - 方法后增强
```

##### 2.2.1.2. UML 图例

<img src="https://static.xkcoding.com/blog/2019-08-21-proxy-dynamicproxy-jdk-uml.png" alt="代理模式-动态代理-JDK动态代理" />

#### 2.2.2. CGLIB 动态代理

> 注意：CGLIB不能代理 `final` 修饰的类/方法

##### 2.2.2.1. 代码实现

- 具体实现

```java
/**
 * <p>
 * 火车票
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 23:18
 */
public class TrainTicket {
    public void sell() {
        System.out.println("火车票");
    }
}

/**
 * <p>
 * CGLIB动态代理类，售票员(不论什么票都卖)
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 22:35
 */
public class Conductor implements MethodInterceptor {

    public Object getInstance(Class<?> clazz) {
        // Enhancer 相当于 JDK 动态代理的 Proxy 类
        Enhancer enhancer = new Enhancer();
        // 设置动态生成的对象的父类为传进来的 被代理类
        enhancer.setSuperclass(clazz);
        // MethodInterceptor 继承 Callback 接口
        enhancer.setCallback(this);
        return enhancer.create();
    }

    /**
     * 代理对象执行的所有方法都会走这个方法
     *
     * @param o           被代理的对象
     * @param method      被代理对象需要执行的方法
     * @param objects     被代理对象需要执行的方法 参数
     * @param methodProxy 触发父类的方法对象
     * @return 被代理对象需要执行的方法 返回值
     * @throws Throwable 抛出的异常信息
     */
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        // 调用生成代理对象的父类方法
        Object result = methodProxy.invokeSuper(o, objects);
        after();
        return result;
    }

    private void before() {
        System.out.println("动态代理 - CGLIB动态代理 - 方法前增强");
    }

    private void after() {
        System.out.println("动态代理 - CGLIB动态代理 - 方法后增强");
    }

}
```

- 测试类

```java
/**
 * <p>
 * 代理模式 - 动态代理 - CGLIB动态代理，测试类
 * </p>
 *
 * @author yangkai.shen
 * @date Created in 2019-08-20 23:16
 */
public class PatternTest {
    public static void main(String[] args) {
        // 代理火车票
        TrainTicket trainTicket = (TrainTicket) new Conductor().getInstance(TrainTicket.class);
        trainTicket.sell();

        // 代理演唱会门票
        MusicTicket musicTicket = (MusicTicket) new Conductor().getInstance(MusicTicket.class);
        musicTicket.sell();
    }
}
```

- 测试结果

```bash
动态代理 - CGLIB动态代理 - 方法前增强
火车票
动态代理 - CGLIB动态代理 - 方法后增强
动态代理 - CGLIB动态代理 - 方法前增强
卖演唱会门票
动态代理 - CGLIB动态代理 - 方法后增强
```

##### 2.2.2.2. UML 图例

<img src="https://static.xkcoding.com/blog/2019-08-21-proxy-dynamicproxy-cglib-uml.png" alt="代理模式-动态代理-CGLIB动态代理" />

## 3. 应用

```java
// Spring AOP
```

## 4. 场景

- 保护目标对象
- 增强目标对象

## 5. 优缺点

**优点：** 代理模式能将代理对象与真实被调用的目标对象分离；一定程度上降低了系统的耦合程度，易于扩展；代理可以起到保护目标对象的作用； 增强目标对象的职责

**缺点：** 代理模式会造成系统设计中类的数目增加；在客户端和目标对象之间增加了一个代理对象，会造成请求处 理速度变慢；增加了系统的复杂度

## 6. 拓展

### 6.1. JDK 动态代理的原理分析

- 代码实现主要步骤

```java
// 1. 根据 2.2.1.1 章节的代码实现可以看出，我们的代理类需要实现 InvocationHandler 接口，实现 invoke 方法

// 2. 具体 Proxy.newProxyInstance() 获得代理对象

// 3. 调用生成的代理对象的方法，此时代理对象已获得增强
```

- 源码剖析

首先我们将断点打在 [这个位置](https://github.com/xkcoding/design-pattern/blob/107158c96ed2a23d8aabf21f84cf0386169942c9/src/main/java/com/xkcoding/design/pattern/structural/proxy/dynamicproxy/jdk/run/PatternTest.java#L20) 如下图所示，可以发现，此时这个 `musicTicket` 对象的引用有点奇怪，居然是 `$Proxy0@554`，证明该对象是通过代理生成的新的代理类创建的，而不是由原生的 `MusicTicket` 类创建的。

<img src="https://static.xkcoding.com/blog/2019-08-22-095324.png"/>

为什么嘞？我们来瞄一波源码。

```java
// 1. musicTicket 是通过我们定义的 getInstance 方法返回的，在 getInstance 方法里，我们通过调用 Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this)

// 2. 我们看看 java.lang.reflect.Proxy#newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h) 
// java.lang.reflect.Proxy#newProxyInstance 主要工作就是①生成代理类②根据代理类获取构造方法③通过构造方法生成代理对象
// ①生成代理类 -> Class<?> cl = getProxyClass0(loader, intfs);
// ②根据代理类获取构造方法 -> final Constructor<?> cons = cl.getConstructor(constructorParams);
// ③通过构造方法生成代理对象 -> return cons.newInstance(new Object[]{h});

// 3. 这里的重点在于生成代理类，所以我们看看 getProxyClass0 这个方法 -> java.lang.reflect.Proxy#getProxyClass0(ClassLoader loader,Class<?>... interfaces)

/**
 * Generate a proxy class.  Must call the checkProxyAccess method
 * to perform permission checks before calling this.
 * 生成代理类，调用该方法前，必须先执行checkProxyAccess方法校验是否可以生成代理类。
 */
private static Class<?> getProxyClass0(ClassLoader loader,Class<?>... interfaces) {
    // 这里需要注意：接口的数量有最大限制，不可以超过 65535
    if (interfaces.length > 65535) {
        throw new IllegalArgumentException("interface limit exceeded");
    }

    // If the proxy class defined by the given loader implementing
    // the given interfaces exists, this will simply return the cached copy;
    // otherwise, it will create the proxy class via the ProxyClassFactory
    // 如果缓存中存在代理类，则直接返回，如果不存在，则会调用ProxyClassFactory类生成代理类
    return proxyClassCache.get(loader, interfaces);
}

// 4. 我们首次调用的时候，缓存里肯定是不存在的，所以我们先看看这个 proxyClassCache 到底是何方神圣？
private static final WeakCache<ClassLoader, Class<?>[], Class<?>> proxyClassCache = new WeakCache<>(new KeyFactory(), new ProxyClassFactory());

// 4.1. 这里的 WeakCache 是JDK自己通过 ConcurrentMap 实现的一个缓存
// 4.2. 键：KeyFactory 就是 ClassLoader 类加载器
// 4.3. 值：ProxyClassFactory 就是代理类的工厂类对象

//5. 我们查看下 java.lang.reflect.WeakCache#get(K key, P parameter) 这个方法里到底是怎么处理的
/**
 * @param key 类加载器
 * @param parameter 接口数组
 */
public V get(K key, P parameter) {
    // 校验接口数组，必须存在接口，否则直接抛出 NPE
    Objects.requireNonNull(parameter);

    // 清除已经被GC回收的对象引用
    expungeStaleEntries();

    // 将 ClassLoader 转化为 CacheKey，此时cacheKey为一级缓存的key
    Object cacheKey = WeakCache.CacheKey.valueOf(key, refQueue);

    // lazily install the 2nd level valuesMap for the particular cacheKey
    // 根据一级缓存的key获取二级缓存
    ConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);
    // 二级缓存不存在，创建一个空的二级缓存
    if (valuesMap == null) {
        ConcurrentMap<Object, Supplier<V>> oldValuesMap
                = map.putIfAbsent(cacheKey,
                valuesMap = new ConcurrentHashMap<>());
        if (oldValuesMap != null) {
            valuesMap = oldValuesMap;
        }
    }

    // create subKey and retrieve the possible Supplier<V> stored by that
    // subKey from valuesMap
    // 根据 ClassLoader 和 接口数组，创建二级缓存的key
    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
    // 通过二级缓存的key获取值
    Supplier<V> supplier = valuesMap.get(subKey);
    WeakCache.Factory factory = null;

    // 死循环重试，直到返回对象为止
    while (true) {
        // 程序的出口分支
        if (supplier != null) {
            // supplier might be a Factory or a CacheValue<V> instance
            // 根据下方的方法可以看出 supplier 可能是 WeakCache.Factory 也可能是 CacheValue
            // 具体验证的细节，在 supplier 的实现类里去判断是什么类型，然后将值返回
            V value = supplier.get();
            // 如果拿到对象，则退出循环，拿不到对象，继续走循环重试
            if (value != null) {
                return value;
            }
        }
        // else no supplier in cache
        // or a supplier that returned null (could be a cleared CacheValue
        // or a Factory that wasn't successful in installing the CacheValue)

        // lazily construct a Factory
        // 如果二级缓存的key取不到值，并且Factory不存在，则去创建Factory对象，这一条件分支，若执行，仅会执行一次
        // 在下方代码可见，创建的Factory对象会去充当二级缓存的值
        if (factory == null) {
            factory = new WeakCache.Factory(key, parameter, subKey, valuesMap);
        }

        if (supplier == null) {
            // 如果二级缓存的key取不到值, 就将factory作为二级缓存对应的值放入
            // 防止被其他线程修改，所以使用 putIfAbsent 方法是如果存在 subKey，就取出来直接用，如果不存在，则将 factory 放入
            supplier = valuesMap.putIfAbsent(subKey, factory);
            // 存放失败的情况，强制将 supplier = factory，此时factory成功加入二级缓存
            if (supplier == null) {
                // successfully installed Factory
                supplier = factory;
            }
            // else retry with winning supplier
        } else {
            // 如果被其他线程修改，就尝试将factory替换旧值
            if (valuesMap.replace(subKey, supplier, factory)) {
                // successfully replaced
                // cleared CacheEntry / unsuccessful Factory
                // with our Factory
                // 替换成功
                supplier = factory;
            } else {
                // retry with current supplier
                // 替换失败，则继续使用旧值
                supplier = valuesMap.get(subKey);
            }
        }
    }
}

// 6. 根据如上代码，这里关键：①二级缓存key的创建②二级缓存只的获取
// ①二级缓存key的创建 -> Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
// ②二级缓存只的获取 -> supplier.get()

未完待续 。。。。。
```



### 6.2. CGLIB 动态代理的原理分析



### 6.3. JDK 动态代理与 CGLIB 动态代理的区别

1. JDK 动态代理生成的代理对象是实现了被代理对象的接口，CGLIB 动态代理生成的代理对象是继承了被代理对象。
2. JDK 和CGLIB 都是在运行期生成字节码，JDK 是直接写 class 字节码，CGLIB 使用 ASM 框架写 class 字节码，CGLIB 代理实现更复杂，`CGLIB 生成代理类的效率比 JDK 生成代理类效率低`。
3. JDK调用代理方法，是通过反射机制调用，CGLIB是通过 FastClass机制直接调用方法，`CGLIB 的被代理类执行效率比 JDK 的被代理类更高`。

### 6.3. Spring 中代理的选择原则

1. 当Bean有实现接口时，Spring就会用JDK的动态代理。
2. 当Bean没有实现接口时，Spring选择CGLib。
3. Spring可以通过配置强制使用CGLib，只需在Spring的配置文件中加入如下代码：

```xml
<aop:aspectj-autoproxy proxy-target-class="true"/>
```

## 7. 完整代码地址

https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/structural/proxy